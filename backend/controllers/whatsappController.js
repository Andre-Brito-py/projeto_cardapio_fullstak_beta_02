import whatsappService from '../services/whatsappService.js';
import WhatsAppConfig from '../models/whatsappModel.js';
import WhatsAppMessage from '../models/whatsappMessageModel.js';
import mongoose from 'mongoose';

/**
 * Webhook para verificaÃ§Ã£o do WhatsApp
 */
const verifyWebhook = async (req, res) => {
    try {
        const mode = req.query['hub.mode'];
        const token = req.query['hub.verify_token'];
        const challenge = req.query['hub.challenge'];
        const storeId = req.query.storeId || req.headers['x-store-id'];

        if (!storeId) {
            return res.status(400).json({ error: 'Store ID Ã© obrigatÃ³rio' });
        }

        const result = await whatsappService.verifyWebhook(mode, token, challenge, storeId);
        res.status(200).send(result);
    } catch (error) {
        console.error('Erro na verificaÃ§Ã£o do webhook:', error);
        res.status(403).json({ error: error.message });
    }
};

/**
 * Webhook para receber mensagens do WhatsApp
 */
const receiveMessage = async (req, res) => {
    try {
        const storeId = req.query.storeId || req.headers['x-store-id'];
        
        if (!storeId) {
            return res.status(400).json({ error: 'Store ID Ã© obrigatÃ³rio' });
        }

        const result = await whatsappService.processIncomingMessage(req.body, storeId);
        
        if (result.success) {
            res.status(200).json({ message: 'Mensagem processada com sucesso' });
        } else {
            res.status(500).json({ error: result.error });
        }
    } catch (error) {
        console.error('Erro ao processar mensagem:', error);
        res.status(500).json({ error: error.message });
    }
};

/**
 * Obter configuraÃ§Ã£o do WhatsApp
 */
const getConfig = async (req, res) => {
    try {
        const storeId = req.storeId;
        const config = await whatsappService.getConfig(storeId);
        
        if (!config) {
            return res.status(404).json({ error: 'ConfiguraÃ§Ã£o nÃ£o encontrada' });
        }

        // Remover dados sensÃ­veis da resposta
        const safeConfig = {
            ...config.toObject(),
            accessToken: config.accessToken ? '***' : null,
            webhookVerifyToken: config.webhookVerifyToken ? '***' : null
        };

        res.json(safeConfig);
    } catch (error) {
        console.error('Erro ao obter configuraÃ§Ã£o:', error);
        res.status(500).json({ error: error.message });
    }
};

/**
 * Salvar configuraÃ§Ã£o do WhatsApp
 */
const saveConfig = async (req, res) => {
    try {
        const storeId = req.storeId;
        const configData = req.body;

        // Validar dados obrigatÃ³rios
        if (configData.accessToken && !configData.phoneNumberId) {
            return res.status(400).json({ error: 'Phone Number ID Ã© obrigatÃ³rio quando Access Token Ã© fornecido' });
        }

        const config = await whatsappService.saveConfig(storeId, configData);
        
        // Remover dados sensÃ­veis da resposta
        const safeConfig = {
            ...config.toObject(),
            accessToken: config.accessToken ? '***' : null,
            webhookVerifyToken: config.webhookVerifyToken ? '***' : null
        };

        res.json({
            message: 'ConfiguraÃ§Ã£o salva com sucesso',
            config: safeConfig
        });
    } catch (error) {
        console.error('Erro ao salvar configuraÃ§Ã£o:', error);
        res.status(500).json({ error: error.message });
    }
};

/**
 * Enviar mensagem manual
 */
const sendMessage = async (req, res) => {
    try {
        const storeId = req.storeId;
        const { to, message, messageType = 'text' } = req.body;

        if (!to || !message) {
            return res.status(400).json({ error: 'DestinatÃ¡rio e mensagem sÃ£o obrigatÃ³rios' });
        }

        const result = await whatsappService.sendMessage({
            storeId,
            to,
            message,
            messageType
        });

        res.json({
            message: 'Mensagem enviada com sucesso',
            messageId: result.messageId
        });
    } catch (error) {
        console.error('Erro ao enviar mensagem:', error);
        res.status(500).json({ error: error.message });
    }
};

/**
 * Obter histÃ³rico de conversa
 */
const getConversationHistory = async (req, res) => {
    try {
        const storeId = req.storeId;
        const { customerPhone } = req.params;
        const limit = parseInt(req.query.limit) || 50;

        if (!customerPhone) {
            return res.status(400).json({ error: 'Telefone do cliente Ã© obrigatÃ³rio' });
        }

        const history = await whatsappService.getConversationHistory(storeId, customerPhone, limit);
        
        res.json({
            customerPhone,
            messages: history.reverse(), // Ordem cronolÃ³gica
            total: history.length
        });
    } catch (error) {
        console.error('Erro ao obter histÃ³rico:', error);
        res.status(500).json({ error: error.message });
    }
};

/**
 * Obter lista de conversas ativas
 */
const getActiveConversations = async (req, res) => {
    try {
        const storeId = new mongoose.Types.ObjectId(req.storeId);
        const limit = parseInt(req.query.limit) || 20;

        const conversations = await whatsappService.getActiveConversations(storeId, limit);
        
        res.json({
            conversations: conversations.map(conv => ({
                customerPhone: conv._id,
                customerName: conv.lastMessage.customerName,
                lastMessage: {
                    content: conv.lastMessage.content.text || '[MÃ­dia]',
                    timestamp: conv.lastMessage.timestamp,
                    direction: conv.lastMessage.direction
                },
                messageCount: conv.messageCount,
                unreadCount: 0 // Implementar lÃ³gica de nÃ£o lidas se necessÃ¡rio
            }))
        });
    } catch (error) {
        console.error('Erro ao obter conversas:', error);
        res.status(500).json({ error: error.message });
    }
};

/**
 * Testar conexÃ£o com WhatsApp
 */
const testConnection = async (req, res) => {
    try {
        const storeId = req.storeId;
        const config = await whatsappService.getConfig(storeId);
        
        if (!config || !config.accessToken || !config.phoneNumberId) {
            return res.status(400).json({ 
                error: 'ConfiguraÃ§Ã£o incompleta. Verifique Access Token e Phone Number ID' 
            });
        }

        // Tentar enviar uma mensagem de teste para o prÃ³prio nÃºmero (se configurado)
        const testPhone = req.body.testPhone;
        
        if (!testPhone) {
            return res.status(400).json({ 
                error: 'NÃºmero de teste Ã© obrigatÃ³rio para verificar a conexÃ£o' 
            });
        }

        await whatsappService.sendMessage({
            storeId,
            to: testPhone,
            message: 'ðŸ¤– Teste de conexÃ£o WhatsApp Business API - ConexÃ£o estabelecida com sucesso!'
        });

        // Atualizar status da conexÃ£o
        await WhatsAppConfig.findOneAndUpdate(
            { storeId },
            { 
                isConnected: true, 
                connectionStatus: 'connected',
                lastConnectionAt: new Date()
            }
        );

        res.json({ 
            message: 'ConexÃ£o testada com sucesso! Mensagem de teste enviada.',
            status: 'connected'
        });
    } catch (error) {
        console.error('Erro ao testar conexÃ£o:', error);
        
        // Atualizar status de erro
        await WhatsAppConfig.findOneAndUpdate(
            { storeId: req.storeId },
            { 
                isConnected: false, 
                connectionStatus: 'error'
            }
        );

        res.status(500).json({ 
            error: 'Falha na conexÃ£o: ' + error.message,
            status: 'error'
        });
    }
};

/**
 * Obter estatÃ­sticas das mensagens
 */
const getMessageStats = async (req, res) => {
    try {
        const storeId = new mongoose.Types.ObjectId(req.storeId);
        const { period = '7d' } = req.query;
        
        let startDate = new Date();
        switch (period) {
            case '1d':
                startDate.setDate(startDate.getDate() - 1);
                break;
            case '7d':
                startDate.setDate(startDate.getDate() - 7);
                break;
            case '30d':
                startDate.setDate(startDate.getDate() - 30);
                break;
            default:
                startDate.setDate(startDate.getDate() - 7);
        }

        const stats = await WhatsAppMessage.aggregate([
            {
                $match: {
                    storeId: storeId,
                    timestamp: { $gte: startDate }
                }
            },
            {
                $group: {
                    _id: null,
                    totalMessages: { $sum: 1 },
                    inboundMessages: {
                        $sum: { $cond: [{ $eq: ['$direction', 'inbound'] }, 1, 0] }
                    },
                    outboundMessages: {
                        $sum: { $cond: [{ $eq: ['$direction', 'outbound'] }, 1, 0] }
                    },
                    processedByLisa: {
                        $sum: { $cond: ['$processedByLisa', 1, 0] }
                    },
                    uniqueCustomers: { $addToSet: '$customerPhone' }
                }
            },
            {
                $project: {
                    _id: 0,
                    totalMessages: 1,
                    inboundMessages: 1,
                    outboundMessages: 1,
                    processedByLisa: 1,
                    uniqueCustomers: { $size: '$uniqueCustomers' }
                }
            }
        ]);

        const result = stats[0] || {
            totalMessages: 0,
            inboundMessages: 0,
            outboundMessages: 0,
            processedByLisa: 0,
            uniqueCustomers: 0
        };

        res.json({
            period,
            stats: result
        });
    } catch (error) {
        console.error('Erro ao obter estatÃ­sticas:', error);
        res.status(500).json({ error: error.message });
    }
};

export {
    verifyWebhook,
    receiveMessage,
    getConfig,
    saveConfig,
    sendMessage,
    getConversationHistory,
    getActiveConversations,
    testConnection,
    getMessageStats
};